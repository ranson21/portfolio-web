# cloudbuild.yaml
steps:
  # Get latest version tag
  - name: 'gcr.io/cloud-builders/git'
    entrypoint: 'bash'
    secretEnv: ['GITHUB_TOKEN']
    args:
      - '-c'
      - |
        # Install curl and jq
        apt-get update && apt-get install -y curl jq

        # Get the latest release using GitHub API
        LATEST_TAG=$(curl -s -H "Authorization: token $$GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$_REPO_OWNER/portfolio-web/releases/latest" | \
          jq -r '.tag_name' || echo "v0.0.0")

        echo "Latest release tag: $${LATEST_TAG}"
        echo "$${LATEST_TAG}" > current_version.txt

  # Process PR info and determine version type
  - name: 'gcr.io/cloud-builders/git'
    entrypoint: 'bash'
    secretEnv: ['GITHUB_TOKEN']
    args:
      - '-c'
      - |
        # Install curl and jq
        apt-get update && apt-get install -y curl jq

        if [ "$_IS_MERGE" = "true" ]; then
          # Get the last merge commit message
          MERGE_MSG=$(git log -1 --pretty=%B)
          # Extract PR number from merge commit message (format: Merge pull request #XX)
          PR_NUMBER=$(echo "$${MERGE_MSG}" | grep -o '#[0-9]\+' | tr -d '#')
          
          if [ ! -z "$${PR_NUMBER}" ]; then
            echo "Found PR number: $${PR_NUMBER}"
            
            # Fetch PR labels using GitHub API (including closed PRs)
            curl -s -H "Authorization: token $$GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$_REPO_OWNER/portfolio-web/pulls/$${PR_NUMBER}?state=all" > pr_info.json
            
            # Add debug output
            echo "Debug: PR Info Response:"
            cat pr_info.json
            
            # Extract labels with error handling
            LABELS=$(cat pr_info.json | jq -r '.labels[]?.name // empty' | tr '\n' ',' | sed 's/,$//')
            
            echo "Debug: Found labels: $${LABELS}"
            
            if [[ $${LABELS} == *"major"* ]]; then
              echo "major" > version_type.txt
            elif [[ $${LABELS} == *"minor"* ]]; then
              echo "minor" > version_type.txt
            elif [[ $${LABELS} == *"patch"* ]]; then
              echo "patch" > version_type.txt
            else
              echo "timestamp" > version_type.txt
            fi
          else
            echo "No PR number found, using timestamp"
            echo "timestamp" > version_type.txt
          fi
          
          echo "Debug: Final version type: $(cat version_type.txt)"
        else
          # Original PR label processing
          if [ -z "$_PR_TYPE" ] || [ "$_PR_TYPE" = "[]" ]; then
            echo "Debug: No labels found, using timestamp"
            echo "timestamp" > version_type.txt
          else
            LABEL=$(echo "$_PR_TYPE" | tr -d '[]"' | cut -d',' -f1 | tr -d ' ')
            echo "$${LABEL}" > version_type.txt
          fi
        fi

        echo "Debug: Final version_type: $(cat version_type.txt)"

  # Bump version based on PR label or use timestamp
  - name: 'python:3.9'
    entrypoint: 'python'
    args:
      - '-c'
      - |
        import os
        import re
        from datetime import datetime

        def bump_version(current, bump_type):
            print(f"Debug: Processing bump_type: {bump_type}")
            # Remove 'v' prefix if present
            current = current.lstrip('v')
            
            # If PR_TYPE is timestamp, use current version with timestamp
            if bump_type.lower().strip() == 'timestamp':
                timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
                return f"v{current}-{timestamp}"
            
            # Regular semantic version bumping
            major, minor, patch = map(int, current.split('.'))
            bump_type = bump_type.lower().strip()
            print(f"Debug: Cleaned bump_type: {bump_type}")
            
            if bump_type == 'major':
                major += 1
                minor = 0
                patch = 0
            elif bump_type == 'minor':
                minor += 1
                patch = 0
            elif bump_type == 'patch':
                patch += 1
            else:
                print(f"Debug: Unrecognized bump_type, defaulting to timestamp")
                timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
                return f"v{current}-{timestamp}"
                
            return f"v{major}.{minor}.{patch}"

        # Read current version
        with open('current_version.txt', 'r') as f:
            current_version = f.read().strip()
        print(f"Debug: Current version: {current_version}")

        # Read version type from file
        with open('version_type.txt', 'r') as f:
            bump_type = f.read().strip()
        print(f"Debug: Read bump_type from file: {bump_type}")

        # Calculate new version
        new_version = bump_version(current_version, bump_type)

        # Save new version
        with open('new_version.txt', 'w') as f:
            f.write(new_version)
            
        # Save whether this is a semantic version for later use
        is_semantic = bump_type.lower().strip() in ['major', 'minor', 'patch']
        with open('is_semantic.txt', 'w') as f:
            f.write(str(is_semantic).lower())

        print(f"Debug: is_semantic: {is_semantic}")
        print(f"Version update: {current_version} -> {new_version}")

  # Install dependencies
  - name: 'node:18'
    entrypoint: npm
    args: ['install']

  # Build the Vite app
  - name: 'node:18'
    entrypoint: npm
    args: ['run', 'build']

  # Create tar archive of dist directory
  - name: 'ubuntu'
    args: ['tar', '-czf', 'release.tar.gz', '-C', 'dist', '.']

  # Create GitHub release with new version
  - name: 'gcr.io/cloud-builders/curl'
    entrypoint: 'bash'
    secretEnv: ['GITHUB_TOKEN']
    args:
      - '-c'
      - |
        # Install curl and jq
        apt-get update && apt-get install -y jq

        NEW_VERSION=$(cat new_version.txt)
        IS_SEMANTIC=$(cat is_semantic.txt)

        # Set draft status based on whether this is a semantic version
        if [ "$_IS_MERGE" = "true" ]; then
          DRAFT="false"
        else
          DRAFT="true"
        fi

        curl -X POST \
          -H "Authorization: token $$GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          https://api.github.com/repos/ranson21/portfolio-web/releases \
          -d '{
            "tag_name": "'$${NEW_VERSION}'",
            "name": "Release '$${NEW_VERSION}'",
            "body": "Release version '$${NEW_VERSION}'",
            "draft": '$${DRAFT}',
            "prerelease": false
          }' > release.json

        # Extract release id
        RELEASE_ID=$(cat release.json | jq .id)

        # Upload asset
        curl -X POST \
          -H "Authorization: token $$GITHUB_TOKEN" \
          -H "Content-Type: application/gzip" \
          -H "Accept: application/vnd.github.v3+json" \
          --data-binary @release.tar.gz \
          "https://uploads.github.com/repos/ranson21/portfolio-web/releases/$${RELEASE_ID}/assets?name=release.tar.gz"

  # Update parent repo submodule and create PR
  - name: 'gcr.io/cloud-builders/git'
    entrypoint: 'bash'
    secretEnv: ['GITHUB_TOKEN']
    args:
      - '-c'
      - |
        # Only run this step if IS_MERGE is true
        if [ "$_IS_MERGE" != "true" ]; then
          echo "Skipping submodule update as this is not a merge to main"
          exit 0
        fi

        # Install necessary tools
        apt-get update && apt-get install -y curl jq

        # Clone the parent repository
        git clone https://oauth2:$$GITHUB_TOKEN@github.com/$_REPO_OWNER/portfolio.git parent-repo
        cd parent-repo

        # Configure Git
        git config user.email "cloudbuild@example.com"
        git config user.name "Cloud Build"

        # Get the new version
        NEW_VERSION=$(cat ../new_version.txt)

        # Create a new branch
        BRANCH_NAME="update-portfolio-web-$${NEW_VERSION}"
        git checkout -b $${BRANCH_NAME}

        # Update the submodule
        cd apps/web/portfolio
        git fetch origin
        git checkout master
        cd ../../..

        # Commit the changes
        git add .
        git commit -m "chore: update portfolio-web submodule to $${NEW_VERSION}"

        # Push the branch
        git push origin $${BRANCH_NAME}

        # Create PR using GitHub API
        curl -X POST \
          -H "Authorization: token $$GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          https://api.github.com/repos/$_REPO_OWNER/portfolio/pulls \
          -d '{
            "title": "Update portfolio-web submodule to '"$${NEW_VERSION}"'",
            "body": "This PR updates the portfolio-web submodule to version '"$${NEW_VERSION}"'",
            "head": "'"$${BRANCH_NAME}"'",
            "base": "master"
          }'

availableSecrets:
  secretManager:
    - versionName: projects/$PROJECT_ID/secrets/github_token/versions/latest
      env: 'GITHUB_TOKEN'

substitutions:
  _PR_TYPE: '' # This will now be populated by the PR label if it exists
